<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EGSnrc C++ class library: EGS_NDGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EGSnrc C++ class library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>EGS_NDGeometry Class Reference<div class="ingroups"><a class="el" href="group__Geometry.html">Geometry module</a> &#124; <a class="el" href="group__CompositeG.html">Composite Geometries</a></div></h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="EGS_NDGeometry" --><!-- doxytag: inherits="EGS_BaseGeometry" -->
<p>A class modeling a N-dimensional geometry.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="egs__nd__geometry_8h_source.html">egs_nd_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EGS_NDGeometry:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEGS__NDGeometry.png" usemap="#EGS_NDGeometry_map" alt=""/>
  <map id="EGS_NDGeometry_map" name="EGS_NDGeometry_map">
<area href="classEGS__BaseGeometry.html" alt="EGS_BaseGeometry" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>

<p><a href="classEGS__NDGeometry-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#a9770bb13e211b11a7b6e2430d0b59df8">EGS_NDGeometry</a> (int ng, <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> **G, const string &amp;Name=&quot;&quot;, bool O=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#a22ef52b4fa55453da48935653d35efd0">EGS_NDGeometry</a> (vector&lt; <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> * &gt; &amp;G, const string &amp;Name=&quot;&quot;, bool O=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9d19606a416d781828057a31f7b194"></a><!-- doxytag: member="EGS_NDGeometry::isInside" ref="abe9d19606a416d781828057a31f7b194" args="(const EGS_Vector &amp;x)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInside</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbc701098479d6c4338c717daeb39b88"></a><!-- doxytag: member="EGS_NDGeometry::isWhere" ref="afbc701098479d6c4338c717daeb39b88" args="(const EGS_Vector &amp;x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>isWhere</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce496356f86c21ef53e5cccb71a3767"></a><!-- doxytag: member="EGS_NDGeometry::inside" ref="afce496356f86c21ef53e5cccb71a3767" args="(const EGS_Vector &amp;x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>inside</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa215c49e55b8f0b158331b47bae7417c"></a><!-- doxytag: member="EGS_NDGeometry::howfarToOutside" ref="aa215c49e55b8f0b158331b47bae7417c" args="(int ireg, const EGS_Vector &amp;x, const EGS_Vector &amp;u)" -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>howfarToOutside</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaacf589c62b96ccce89f340d3919e2a"></a><!-- doxytag: member="EGS_NDGeometry::howfar" ref="afaacf589c62b96ccce89f340d3919e2a" args="(int ireg, const EGS_Vector &amp;x, const EGS_Vector &amp;u, EGS_Float &amp;t, int *newmed=0, EGS_Vector *normal=0)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>howfar</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u, EGS_Float &amp;t, int *newmed=0, <a class="el" href="classEGS__Vector.html">EGS_Vector</a> *normal=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06fad8e651d28f378ce1a0f0e14cb447"></a><!-- doxytag: member="EGS_NDGeometry::hownear" ref="a06fad8e651d28f378ce1a0f0e14cb447" args="(int ireg, const EGS_Vector &amp;x)" -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>hownear</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac52a98ae15daa373aa564e5f6b401fd3"></a><!-- doxytag: member="EGS_NDGeometry::getMaxStep" ref="ac52a98ae15daa373aa564e5f6b401fd3" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxStep</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5139ebac37c42a425b6e3babbf9fe3f"></a><!-- doxytag: member="EGS_NDGeometry::getType" ref="ac5139ebac37c42a425b6e3babbf9fe3f" args="() const " -->
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getType</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a719daeb7f45d6ee815b154a0055e8341"></a><!-- doxytag: member="EGS_NDGeometry::printInfo" ref="a719daeb7f45d6ee815b154a0055e8341" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>printInfo</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71e9c7f6ddbe50b42b04889f1e7df79c"></a><!-- doxytag: member="EGS_NDGeometry::getLabelRegions" ref="a71e9c7f6ddbe50b42b04889f1e7df79c" args="(const string &amp;str, vector&lt; int &gt; &amp;regs)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>getLabelRegions</b> (const string &amp;str, vector&lt; int &gt; &amp;regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eda73f0531258b9f6fa09aca804f37f"></a><!-- doxytag: member="EGS_NDGeometry::ndRegions" ref="a4eda73f0531258b9f6fa09aca804f37f" args="(int r, int dim, int dimk, int k, vector&lt; int &gt; &amp;regs)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndRegions</b> (int r, int dim, int dimk, int k, vector&lt; int &gt; &amp;regs)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae8a80eb721e83dacf5df9444fa3a318"></a><!-- doxytag: member="EGS_NDGeometry::setup" ref="aae8a80eb721e83dacf5df9444fa3a318" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#aa001ace3e36322ed8998b2780a10d316">setMedia</a> (<a class="el" href="classEGS__Input.html">EGS_Input</a> *inp, int nmed, const int *med_ind)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define media.  <a href="#aa001ace3e36322ed8998b2780a10d316"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3fc033b4a4fdeb113887bc29e04bc30"></a><!-- doxytag: member="EGS_NDGeometry::N" ref="ad3fc033b4a4fdeb113887bc29e04bc30" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#ad3fc033b4a4fdeb113887bc29e04bc30">N</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of dimensions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4df59e642b5510f9f6f4664078acd7c"></a><!-- doxytag: member="EGS_NDGeometry::g" ref="ac4df59e642b5510f9f6f4664078acd7c" args="" -->
<a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#ac4df59e642b5510f9f6f4664078acd7c">g</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9990da49a368ce5d0c59510cfc01411e"></a><!-- doxytag: member="EGS_NDGeometry::n" ref="a9990da49a368ce5d0c59510cfc01411e" args="" -->
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#a9990da49a368ce5d0c59510cfc01411e">n</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for calculating region indeces. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab44ebf94afb8df08740206f7ba34bb1e"></a><!-- doxytag: member="EGS_NDGeometry::ortho" ref="ab44ebf94afb8df08740206f7ba34bb1e" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#ab44ebf94afb8df08740206f7ba34bb1e">ortho</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the geometry orthogonal ? <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a814333b9e55332159c682606729a3b68"></a><!-- doxytag: member="EGS_NDGeometry::type" ref="a814333b9e55332159c682606729a3b68" args="" -->
static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html#a814333b9e55332159c682606729a3b68">type</a> = &quot;EGS_NDGeometry&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The geometry type. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A class modeling a N-dimensional geometry. </p>
<p>To understand an N-dimensional geometry object, consider an XYZ-geometry made from sets of <img class="formulaInl" alt="$n_x+1$" src="form_162.png"/> x-planes, <img class="formulaInl" alt="$n_y+1$" src="form_163.png"/> y-planes and <img class="formulaInl" alt="$n_z+1$" src="form_164.png"/> z-planes. This type of geometry is implemented in the DOSXYZnrc user code and is useful <em>e.g</em>. for the modeling of a computed tomography image of a patient undergoing radiotherapy. The sets of x-, y- and z-planes define <img class="formulaInl" alt="$n_x \cdot n_y \cdot n_z$" src="form_165.png"/> parallelepiped regions (a.k.a. voxels) in space. The regions can be numbered in any way but it is customary to use the convention that when a position is in the <img class="formulaInl" alt="$i$" src="form_0.png"/>'th x-planes region (<em>i.e</em>. between the <img class="formulaInl" alt="$i$" src="form_0.png"/>'th and <img class="formulaInl" alt="$i+1$" src="form_166.png"/>'st x-plane), in the <img class="formulaInl" alt="$j$" src="form_13.png"/>'th y-planes region and in the <img class="formulaInl" alt="$k$" src="form_167.png"/>'th z-planes region, it is in region <img class="formulaInl" alt="$i + n_x j + n_x \cdot n_y \cdot k$" src="form_168.png"/> in the XYZ-geometry. A position is inside an XYZ-geometry if it is inside the x-planes (<em>i.e</em>. it is between the first and last x-plane), inside the y-planes and inside the z-planes. To calculate the distance to any boundary along a given direction (the howfar() method) for a position inside the XYZ-geometry, one calculates the distance <img class="formulaInl" alt="$t_x$" src="form_169.png"/> to the x-planes, the distance <img class="formulaInl" alt="$t_y$" src="form_170.png"/> to the y-panes, the distance <img class="formulaInl" alt="$t_z$" src="form_171.png"/> to the z-planes and then takes the minimum of <img class="formulaInl" alt="$t_x, t_y$" src="form_172.png"/> and <img class="formulaInl" alt="$t_z$" src="form_171.png"/>. To calculate the minimum distance to a boundary in any direction (the hownear() method) for a position inside the XYZ-geometry, one calculates the minimum distances to a boundary in any direction to the x-planes, y-planes and z-planes and takes the minimum of the three distances. Consider now an RZ-geometry, <em>i.e</em>. a geometry made from <img class="formulaInl" alt="$n_z+1$" src="form_164.png"/> z-planes intersecting <img class="formulaInl" alt="$n_r$" src="form_173.png"/> concentric cylinders with their axis along the z-axis to form <img class="formulaInl" alt="$n_z \cdot n_r$" src="form_174.png"/> regions. As with the XYZ-geometry one can use the convention that when a position is inside the <img class="formulaInl" alt="$i$" src="form_0.png"/>'th z-planes region and the <img class="formulaInl" alt="$j$" src="form_13.png"/>'th cylinder region, it is in the <img class="formulaInl" alt="$i + n_z \cdot j$" src="form_175.png"/>'th region of the RZ-geometry. To calculate the distance along a given direction to the RZ-geometry for an inside position, one calculates the distances <img class="formulaInl" alt="$t_z$" src="form_171.png"/> to the planes and <img class="formulaInl" alt="$t_r$" src="form_176.png"/> to the cylinders and takes the minimum of the two. The minimum distance to a boundary in any direction for an inside point is also calculated as the minimum of the corresponding distances to the planes and to the cylinders.</p>
<p>The above discussion should make it clear that, once the howfar(), hownear(), isInside(), etc., methods are available for planes and cylinders, the algorithms for calculating howfar(), hownear()}, isInside(), etc., is essentially the same for XYZ- and RZ-geometries, with the only difference that in the former case one uses 3 geometries to divide the space into regions (<em>i.e</em> one has a 3-dimensional geometry) and in the latter case only 2 geometries (<em>i.e</em> one has a 2-dimensional geometry).</p>
<p>An N-dimensional geometry is a generalization of this concept to an arbitrary number of geometries (dimensions) of arbitrary types (not just planes and/or cylinders): An N-dimensional geometry is a geometry type that is constructed from <img class="formulaInl" alt="$N$" src="form_103.png"/> other geometries <img class="formulaInl" alt="$G_0, G_1, ..., G_{N-1}$" src="form_177.png"/> defining <img class="formulaInl" alt="$n_0, n_1, ..., n_{N-1}$" src="form_178.png"/> regions so that</p>
<ul>
<li>The geometry consists of <img class="formulaInl" alt="$n_0 \cdot n_1 \cdot ... \cdot n_{N-1}$" src="form_179.png"/> regions</li>
<li>A point is inside the geometry if and only if it is inside all of the <img class="formulaInl" alt="$G_0, ..., G_{N-1}$" src="form_180.png"/> geometries.</li>
<li>If a point is inside regions <img class="formulaInl" alt="$i_0, i_1, ..., i_{N-1}$" src="form_181.png"/> in <img class="formulaInl" alt="$G_0, G_1, ..., G_{N-1}$" src="form_177.png"/>, it is inside the region <img class="formulaInl" alt="$i$" src="form_0.png"/>, <p class="formulaDsp">
<img class="formulaDsp" alt="\[ i = \sum_{j=0}^{N-1} i_j m_j~, \quad m_0 = 1~,~~~m_1 = n_0,~~~m_2 = n_0 n_1, ~~~ \cdots ~~~ m_i = m_{i-1} n_{i-1}~, \]" src="form_182.png"/>
</p>
 in the N-dimensional geometry (as in the case of the XYZ and RZ examples above, this is just a convention that is convenient in practice).</li>
<li>If the current position is in region <img class="formulaInl" alt="$i$" src="form_0.png"/> inside the N-dimension geometry, the distance <img class="formulaInl" alt="$t$" src="form_3.png"/> to a boundary in the N-dimension geometry along the direction of motion (needed by the howfar() method) is given by the minimum of the distances <img class="formulaInl" alt="$t_1,...,t_N$" src="form_183.png"/> to a boundary in the geometries <img class="formulaInl" alt="$G_0, ..., G_{N-1}$" src="form_180.png"/>. If this minimum is given by the <img class="formulaInl" alt="$j$" src="form_13.png"/>'th constituent geometry <img class="formulaInl" alt="$G_j$" src="form_130.png"/>, the new region will be <img class="formulaInl" alt="$i + m_j$" src="form_184.png"/>, unless the particle would exit <img class="formulaInl" alt="$G_j$" src="form_130.png"/>, in which case the new region is -1. (this is a direct consequence of the region numbering convention specified in the above equation).</li>
<li>If the current position is outside of the N-dimensional geometry, the distances to the entry point is calculated as follows:<ol type="a">
<li>If the position is outside of <img class="formulaInl" alt="$G_j$" src="form_130.png"/>, calculate the distance <img class="formulaInl" alt="$t_j$" src="form_185.png"/> to the entry point of <img class="formulaInl" alt="$G_j$" src="form_130.png"/></li>
<li>If this distance exists (<em>i.e</em>. the trajectory intersects <img class="formulaInl" alt="$G_j$" src="form_130.png"/>), check if <img class="formulaInl" alt="$\vec{x} + \vec{u} t_j$" src="form_186.png"/> is inside all other geometries. If yes, exit the loop and return <img class="formulaInl" alt="$t_j$" src="form_185.png"/></li>
<li>Repeat a-b for all constituent geometries <img class="formulaInl" alt="$j$" src="form_13.png"/>.</li>
</ol>
This algorithm is also a generalization of the algorithms one uses to calculate distances to the boundary of XYZ-, RZ- and other 2 or 3 dimensional geometries.</li>
<li>If the position is inside, the minimum perpendicular distance to a boundary <img class="formulaInl" alt="$t_\perp$" src="form_46.png"/> in the N-dimensional geometry in any direction (needed for the hownear() method) is given by the minimum of the perpendicular distances from all constituent geometries.</li>
<li>If the position is outside, the <img class="formulaInl" alt="$t_\perp$" src="form_46.png"/> calculation is more complicated and depends upon the orthogonality of the constituent geometries. If the constituent geometries are considered to be orthogonal (more on this below), <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \label{tperp_ortho} t_\perp = \sqrt{ \sum_{j} t_{\perp, j}^2 }~. \end{equation}" src="form_187.png"/>
</p>
 Here, the summation runs over all constituents <img class="formulaInl" alt="$j$" src="form_13.png"/> for which the position is outside. If the constituent geometries are not considered to be orthogonal, then <img class="formulaInl" alt="$t_\perp$" src="form_46.png"/> is the minimum of all perpendicular distances just as in the inside case. To understand this algorithm, consider a XYZ-geometry (which is an orthogonal geometry). If a position is <em>e.g</em>. inside the x- and y-planes but outside the z-planes, the nearest distance to a boundary in any direction is the perpendicular distance to the first or last z-plane (depending on which side the position is). If the position is inside the x-planes but outside of the y-planes and the z-planes, the nearest distance to a boundary in any direction is the distance to one of the edges of the XYZ-geometry and is given by <img class="formulaInl" alt="$\sqrt{t_{\perp,y}^2 + t_{\perp,z}^2}$" src="form_188.png"/> with <img class="formulaInl" alt="$t_{\perp,y}$" src="form_189.png"/> and <img class="formulaInl" alt="$t_{\perp,z}$" src="form_190.png"/> denoting the perpendicular distances to the y- and z-planes intersecting to form this edge. If the position is outside of all 3 plane sets, then the nearest distance to the XYZ-geometry is the distance to one of the corners, <em>i.e</em>. <img class="formulaInl" alt="$\sqrt{t_{\perp,x}^2 + t_{\perp,y}^2 + t_{\perp,z}^2}$" src="form_191.png"/>. Equation (1) is simply a generalization to <img class="formulaInl" alt="$N$" src="form_103.png"/> dimensions. Consider now a 2-dimensional geometry made from the intersection of cones with parallel planes. It is relatively easy to see that for the regions outside of the cones and the planes Eq. (1) overestimates the actual minimum distance in any direction (which is the distance to a point on the circle or ellipse formed by the intersection of the outer-most conical surface with the first or last plane). This geometry is therefore not considered to be orthogonal and one uses the minimum of the perpendicular distances to the planes and the cones.</li>
</ul>
<p>It should be clear from the above explanation of the implementation of the various geometry methods that an N-dimensional geometry can be constructed from any <img class="formulaInl" alt="$N$" src="form_103.png"/> geometries provided that the underlying algorithms apply for the geometrical structure being modeled. An N-dimensional geometry is extremely useful and can be employed to model a wide range of geometries:</p>
<ul>
<li>An XYZ geometry where the three constituents are sets of x-, y- and z-planes.</li>
<li>A RZ geometry where the two constituents are sets of z-cylinders and z-planes (it is of course possible to model a ``RZ'' type geometry with an arbitrary orientation by using the any-axis and any-plane versions of the cylinder and plane sets)</li>
<li>A polar coordinates geometry from sets of spheres and the <a class="el" href="classEGS__ConeSet.html" title="A set of cones with different opening angles but the same axis and apexes.">EGS_ConeSet</a> class with flag set to 2. This type of geometry is useful for instance in the calculation of point spread functions.</li>
<li>One can construct hemi-spheres from a sphere and two planes, prisms with bases at any direction relative to the prism axis from the EGS_Prism class and one of the plane sets, cylinders with bases not perpendicular to the cylinder axis from a set of cylinders and one of the plane sets, cylinders divided into azimuthal segments from one of the cylinder classes and the <a class="el" href="classEGS__IPlanes.html" title="A set of planes intersecting in the same axis.">EGS_IPlanes</a> class, etc.</li>
</ul>
<p>An N-dimensional geometry is defined using the following keys: </p>
<div class="fragment"><pre class="fragment">
library = egs_ndgeometry
dimesions = list of names of previously defined geometries
hownear method = 0 or 1
</pre></div><p> All constituent geometries of the N-dimensional geometry must have been defined previously (<em>i.e</em>. their definition must appear before the definition of the N-dimensional geometry in the input file). The hownear() method input determines if the geometry constituents are considered to be orthogonal with 0 corresponding to orthogonal constituent geometries. It is very hard to automatically determine whether the constituents of an N-dimensional geometry are orthogonal and therefore it is the responsibility of the user to provide this input. Note, however, that the non-orthogonal hownear() version can always be used, it will just underestimate <img class="formulaInl" alt="$t_\perp$" src="form_46.png"/> for orthogonal geometries and make the simulation run somewhat slower.</p>
<p>N-dimensional geometries are used in many of the example geometry files. </p>

<p>Definition at line <a class="el" href="egs__nd__geometry_8h_source.html#l00246">246</a> of file <a class="el" href="egs__nd__geometry_8h_source.html">egs_nd_geometry.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9770bb13e211b11a7b6e2430d0b59df8"></a><!-- doxytag: member="EGS_NDGeometry::EGS_NDGeometry" ref="a9770bb13e211b11a7b6e2430d0b59df8" args="(int ng, EGS_BaseGeometry **G, const string &amp;Name=&quot;&quot;, bool O=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EGS_NDGeometry::EGS_NDGeometry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> **&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>Name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>O</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a N-dimensional geometry from the <em>ng</em> dimensions <em>G</em>. </p>

<p>Definition at line <a class="el" href="egs__nd__geometry_8cpp_source.html#l00047">47</a> of file <a class="el" href="egs__nd__geometry_8cpp_source.html">egs_nd_geometry.cpp</a>.</p>

<p>References <a class="el" href="egs__nd__geometry_8h_source.html#l00499">g</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00719">EGS_BaseGeometry::is_convex</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00119">EGS_BaseGeometry::isConvex()</a>, <a class="el" href="egs__nd__geometry_8h_source.html#l00500">n</a>, <a class="el" href="egs__nd__geometry_8h_source.html#l00498">N</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00653">EGS_BaseGeometry::nreg</a>, and <a class="el" href="egs__base__geometry_8h_source.html#l00261">EGS_BaseGeometry::regions()</a>.</p>

</div>
</div>
<a class="anchor" id="a22ef52b4fa55453da48935653d35efd0"></a><!-- doxytag: member="EGS_NDGeometry::EGS_NDGeometry" ref="a22ef52b4fa55453da48935653d35efd0" args="(vector&lt; EGS_BaseGeometry * &gt; &amp;G, const string &amp;Name=&quot;&quot;, bool O=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EGS_NDGeometry::EGS_NDGeometry </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>Name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>O</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a N-dimensional the array of dimensions <em>G</em>. </p>

<p>Definition at line <a class="el" href="egs__nd__geometry_8cpp_source.html#l00062">62</a> of file <a class="el" href="egs__nd__geometry_8cpp_source.html">egs_nd_geometry.cpp</a>.</p>

<p>References <a class="el" href="egs__nd__geometry_8h_source.html#l00499">g</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00719">EGS_BaseGeometry::is_convex</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00119">EGS_BaseGeometry::isConvex()</a>, <a class="el" href="egs__nd__geometry_8h_source.html#l00500">n</a>, <a class="el" href="egs__nd__geometry_8h_source.html#l00498">N</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00653">EGS_BaseGeometry::nreg</a>, and <a class="el" href="egs__base__geometry_8h_source.html#l00261">EGS_BaseGeometry::regions()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa001ace3e36322ed8998b2780a10d316"></a><!-- doxytag: member="EGS_NDGeometry::setMedia" ref="aa001ace3e36322ed8998b2780a10d316" args="(EGS_Input *inp, int nmed, const int *med_ind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGS_NDGeometry::setMedia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEGS__Input.html">EGS_Input</a> *&#160;</td>
          <td class="paramname"><em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>med_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define media. </p>
<p>This function is re-implemented to permit easier media definition in a N-dimensional geometry. </p>

<p>Reimplemented from <a class="el" href="classEGS__BaseGeometry.html#aa258e78c1b9e6c70c9102def964358a4">EGS_BaseGeometry</a>.</p>

<p>Definition at line <a class="el" href="egs__nd__geometry_8cpp_source.html#l00103">103</a> of file <a class="el" href="egs__nd__geometry_8cpp_source.html">egs_nd_geometry.cpp</a>.</p>

<p>References <a class="el" href="egs__functions_8cpp_source.html#l00135">egsWarning</a>, <a class="el" href="egs__input_8cpp_source.html#l00331">EGS_Input::getInput()</a>, <a class="el" href="egs__base__geometry_8h_source.html#l00676">EGS_BaseGeometry::med</a>, <a class="el" href="egs__base__geometry_8cpp_source.html#l00424">EGS_BaseGeometry::setMedium()</a>, and <a class="el" href="egs__input_8cpp_source.html#l00223">EGS_Input::takeInputItem()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/ftessier/EGSnrc/HEN_HOUSE/egs++/geometry/egs_nd_geometry/<a class="el" href="egs__nd__geometry_8h_source.html">egs_nd_geometry.h</a></li>
<li>/home/ftessier/EGSnrc/HEN_HOUSE/egs++/geometry/egs_nd_geometry/<a class="el" href="egs__nd__geometry_8cpp_source.html">egs_nd_geometry.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
