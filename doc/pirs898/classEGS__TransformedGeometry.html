<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EGSnrc C++ class library: EGS_TransformedGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EGSnrc C++ class library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>EGS_TransformedGeometry Class Reference<div class="ingroups"><a class="el" href="group__Geometry.html">Geometry module</a> &#124; <a class="el" href="group__CompositeG.html">Composite Geometries</a></div></h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="EGS_TransformedGeometry" --><!-- doxytag: inherits="EGS_BaseGeometry" -->
<p>A transformed geometry.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="egs__gtransformed_8h_source.html">egs_gtransformed.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EGS_TransformedGeometry:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEGS__TransformedGeometry.png" usemap="#EGS_TransformedGeometry_map" alt=""/>
  <map id="EGS_TransformedGeometry_map" name="EGS_TransformedGeometry_map">
<area href="classEGS__BaseGeometry.html" alt="EGS_BaseGeometry" shape="rect" coords="0,0,169,24"/>
</map>
 </div></div>

<p><a href="classEGS__TransformedGeometry-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c3516273c1b2ea16c1f81df0a9ed8b4"></a><!-- doxytag: member="EGS_TransformedGeometry::EGS_TransformedGeometry" ref="a4c3516273c1b2ea16c1f81df0a9ed8b4" args="(EGS_BaseGeometry *G, const EGS_AffineTransform &amp;t, const string &amp;Name=&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html#a4c3516273c1b2ea16c1f81df0a9ed8b4">EGS_TransformedGeometry</a> (<a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> *G, const <a class="el" href="classEGS__AffineTransform.html">EGS_AffineTransform</a> &amp;t, const string &amp;Name=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a geometry that is a copy of the geometry <em>G</em> transformed by <em>t</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c4c4e829fbf3d7314ee2b33787836a"></a><!-- doxytag: member="EGS_TransformedGeometry::setTransformation" ref="a17c4c4e829fbf3d7314ee2b33787836a" args="(const EGS_AffineTransform &amp;t)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTransformation</b> (const <a class="el" href="classEGS__AffineTransform.html">EGS_AffineTransform</a> &amp;t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1e2bd7ac47102bd96b1555097a1dae7"></a><!-- doxytag: member="EGS_TransformedGeometry::computeIntersections" ref="ab1e2bd7ac47102bd96b1555097a1dae7" args="(int ireg, int n, const EGS_Vector &amp;x, const EGS_Vector &amp;u, EGS_GeometryIntersections *isections)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>computeIntersections</b> (int ireg, int n, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u, <a class="el" href="structEGS__GeometryIntersections.html">EGS_GeometryIntersections</a> *isections)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae12d3315a053a4f6e2d7232bcd2cd823"></a><!-- doxytag: member="EGS_TransformedGeometry::isRealRegion" ref="ae12d3315a053a4f6e2d7232bcd2cd823" args="(int ireg) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isRealRegion</b> (int ireg) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84d4e58dc8dc2b64b75b607375937271"></a><!-- doxytag: member="EGS_TransformedGeometry::isInside" ref="a84d4e58dc8dc2b64b75b607375937271" args="(const EGS_Vector &amp;x)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInside</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6afc684877bf0e77fb39cd58044625dc"></a><!-- doxytag: member="EGS_TransformedGeometry::isWhere" ref="a6afc684877bf0e77fb39cd58044625dc" args="(const EGS_Vector &amp;x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>isWhere</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa57177765e3d5796a81b3fe0757fd50"></a><!-- doxytag: member="EGS_TransformedGeometry::inside" ref="aaa57177765e3d5796a81b3fe0757fd50" args="(const EGS_Vector &amp;x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>inside</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada937042dd5a58326d4d07c1299c0a4d"></a><!-- doxytag: member="EGS_TransformedGeometry::medium" ref="ada937042dd5a58326d4d07c1299c0a4d" args="(int ireg) const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>medium</b> (int ireg) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14d89ca390f112b1508402f1514687a4"></a><!-- doxytag: member="EGS_TransformedGeometry::howfarToOutside" ref="a14d89ca390f112b1508402f1514687a4" args="(int ireg, const EGS_Vector &amp;x, const EGS_Vector &amp;u)" -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>howfarToOutside</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f52dd542409c072a236da16b5ee191"></a><!-- doxytag: member="EGS_TransformedGeometry::howfar" ref="a80f52dd542409c072a236da16b5ee191" args="(int ireg, const EGS_Vector &amp;x, const EGS_Vector &amp;u, EGS_Float &amp;t, int *newmed=0, EGS_Vector *normal=0)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>howfar</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u, EGS_Float &amp;t, int *newmed=0, <a class="el" href="classEGS__Vector.html">EGS_Vector</a> *normal=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0fccd98bc193df9d55f7da7e7b753c7"></a><!-- doxytag: member="EGS_TransformedGeometry::hownear" ref="aa0fccd98bc193df9d55f7da7e7b753c7" args="(int ireg, const EGS_Vector &amp;x)" -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>hownear</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2d405c3454b9349dfae04f025988e4"></a><!-- doxytag: member="EGS_TransformedGeometry::getMaxStep" ref="aeb2d405c3454b9349dfae04f025988e4" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxStep</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a701c096cabc5370d6659c262b2fee50c"></a><!-- doxytag: member="EGS_TransformedGeometry::hasBooleanProperty" ref="a701c096cabc5370d6659c262b2fee50c" args="(int ireg, EGS_BPType prop) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasBooleanProperty</b> (int ireg, EGS_BPType prop) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf5c0b7f9a23eed4f3caec9f0c2a698"></a><!-- doxytag: member="EGS_TransformedGeometry::setBooleanProperty" ref="a8cf5c0b7f9a23eed4f3caec9f0c2a698" args="(EGS_BPType prop)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBooleanProperty</b> (EGS_BPType prop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab0b8a54acf2ba73c3974b2b14133c3"></a><!-- doxytag: member="EGS_TransformedGeometry::addBooleanProperty" ref="a4ab0b8a54acf2ba73c3974b2b14133c3" args="(int bit)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>addBooleanProperty</b> (int bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c8c718fb918311ddec70d5be5ab5e9b"></a><!-- doxytag: member="EGS_TransformedGeometry::setBooleanProperty" ref="a9c8c718fb918311ddec70d5be5ab5e9b" args="(EGS_BPType prop, int start, int end, int step=1)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBooleanProperty</b> (EGS_BPType prop, int start, int end, int step=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e84dcaeaaa9b186548fb6d841ed2fe9"></a><!-- doxytag: member="EGS_TransformedGeometry::addBooleanProperty" ref="a1e84dcaeaaa9b186548fb6d841ed2fe9" args="(int bit, int start, int end, int step=1)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>addBooleanProperty</b> (int bit, int start, int end, int step=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a991fd4820c6843c9b9529089507cdb0e"></a><!-- doxytag: member="EGS_TransformedGeometry::getType" ref="a991fd4820c6843c9b9529089507cdb0e" args="() const " -->
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getType</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c9855199c6e70b7892661615a72e49e"></a><!-- doxytag: member="EGS_TransformedGeometry::getRelativeRho" ref="a6c9855199c6e70b7892661615a72e49e" args="(int ireg) const " -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>getRelativeRho</b> (int ireg) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab14a93533caaa55834526c67ae97664a"></a><!-- doxytag: member="EGS_TransformedGeometry::setRelativeRho" ref="ab14a93533caaa55834526c67ae97664a" args="(int start, int end, EGS_Float rho)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRelativeRho</b> (int start, int end, EGS_Float rho)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0211610cafae9c4964eac42e0534b16"></a><!-- doxytag: member="EGS_TransformedGeometry::setRelativeRho" ref="ad0211610cafae9c4964eac42e0534b16" args="(EGS_Input *)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRelativeRho</b> (<a class="el" href="classEGS__Input.html">EGS_Input</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f4640569678a46e9040b316874cd0f1"></a><!-- doxytag: member="EGS_TransformedGeometry::getLabelRegions" ref="a6f4640569678a46e9040b316874cd0f1" args="(const string &amp;str, vector&lt; int &gt; &amp;regs)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>getLabelRegions</b> (const string &amp;str, vector&lt; int &gt; &amp;regs)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html#abcd4cafe7f5f385afcfb8978938bb4c6">setMedia</a> (<a class="el" href="classEGS__Input.html">EGS_Input</a> *inp, int, const int *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't define media in the transformed geometry definition.  <a href="#abcd4cafe7f5f385afcfb8978938bb4c6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af78a02f331d0d84d587ea3f642376f82"></a><!-- doxytag: member="EGS_TransformedGeometry::g" ref="af78a02f331d0d84d587ea3f642376f82" args="" -->
<a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html#af78a02f331d0d84d587ea3f642376f82">g</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The geometry being transformed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce6f6fc14d31f224dd90f79e904b0a3"></a><!-- doxytag: member="EGS_TransformedGeometry::T" ref="afce6f6fc14d31f224dd90f79e904b0a3" args="" -->
<a class="el" href="classEGS__AffineTransform.html">EGS_AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html#afce6f6fc14d31f224dd90f79e904b0a3">T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The affine transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dda383c5e9e356f207f41f832974a23"></a><!-- doxytag: member="EGS_TransformedGeometry::type" ref="a7dda383c5e9e356f207f41f832974a23" args="" -->
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html#a7dda383c5e9e356f207f41f832974a23">type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The geometry type. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A transformed geometry. </p>
<p>A transformed geometry is a geometry that has been transformed to a different location and/or orientation by the application of an <a class="el" href="classEGS__AffineTransform.html">affine transformation </a> <img class="formulaInl" alt="$T(R,\vec{t})$" src="form_153.png"/>, where <img class="formulaInl" alt="$R$" src="form_32.png"/> is a rotation matrix (a 3x3 matrix with a determinant of unity) and <img class="formulaInl" alt="$\vec{t}$" src="form_107.png"/> is a translation vector (so that <img class="formulaInl" alt="$\vec{x}' = R \vec{x} + \vec{t}$" src="form_154.png"/>). A transformed geometry is useful for the following two broad classes of situations:</p>
<ul>
<li>It is easier or only possible to define a geometry at a location and orientation different from the location and orientation needed in the simulation (the second case is true for a box, for instance).</li>
<li>One needs two or more replicas of the same geometry object placed at different locations/orientations.</li>
</ul>
<p>The implementation of the geometry methods for this geometry is very simple: one applies the inverse affine transformation to the particle position and the inverse rotation to the particle direction (if needed) and then uses the corresponding method of the geometry being transformed. A transformed geometry is defined using the following keys: </p>
<div class="fragment"><pre class="fragment">
library = egs_gtransformed
my geometry = name of a previously defined geometry
input defining the transformation
</pre></div><p> The input defining the affine transformation is described in <a class="el" href="classEGS__AffineTransform.html#a601a07115aecff1925956a9097e69950" title="Constructs an affine transformation object from the input pointed to by inp and returns a pointer to ...">EGS_AffineTransform::getTransformation()</a>.</p>
<p>Transformed geometries are used in the <code>car.geom, chambers_in_box.geom, seeds_in_xyz.geom</code> and <code>seeds_in_xyz1.geom</code> example geometry files. </p>

<p>Definition at line <a class="el" href="egs__gtransformed_8h_source.html#l00101">101</a> of file <a class="el" href="egs__gtransformed_8h_source.html">egs_gtransformed.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abcd4cafe7f5f385afcfb8978938bb4c6"></a><!-- doxytag: member="EGS_TransformedGeometry::setMedia" ref="abcd4cafe7f5f385afcfb8978938bb4c6" args="(EGS_Input *inp, int, const int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGS_TransformedGeometry::setMedia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEGS__Input.html">EGS_Input</a> *&#160;</td>
          <td class="paramname"><em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Don't define media in the transformed geometry definition. </p>
<p>This function is re-implemented to warn the user to not define media in the definition of a transformed geometry. Instead, media should be defined when specifying the geometry to be transformed. </p>

<p>Reimplemented from <a class="el" href="classEGS__BaseGeometry.html#aa258e78c1b9e6c70c9102def964358a4">EGS_BaseGeometry</a>.</p>

<p>Definition at line <a class="el" href="egs__gtransformed_8cpp_source.html#l00042">42</a> of file <a class="el" href="egs__gtransformed_8cpp_source.html">egs_gtransformed.cpp</a>.</p>

<p>References <a class="el" href="egs__functions_8cpp_source.html#l00135">egsWarning</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/ftessier/EGSnrc/HEN_HOUSE/egs++/geometry/egs_gtransformed/<a class="el" href="egs__gtransformed_8h_source.html">egs_gtransformed.h</a></li>
<li>/home/ftessier/EGSnrc/HEN_HOUSE/egs++/geometry/egs_gtransformed/<a class="el" href="egs__gtransformed_8cpp_source.html">egs_gtransformed.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
