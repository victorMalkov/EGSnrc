<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EGSnrc C++ class library: EGS_VHPGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EGSnrc C++ class library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>EGS_VHPGeometry Class Reference<div class="ingroups"><a class="el" href="group__Geometry.html">Geometry module</a> &#124; <a class="el" href="group__CompositeG.html">Composite Geometries</a></div></h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="EGS_VHPGeometry" --><!-- doxytag: inherits="EGS_BaseGeometry" -->
<p>A Voxelized Human Phantom (VHP) geometry.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="egs__vhp__geometry_8h_source.html">egs_vhp_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EGS_VHPGeometry:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEGS__VHPGeometry.png" usemap="#EGS_VHPGeometry_map" alt=""/>
  <map id="EGS_VHPGeometry_map" name="EGS_VHPGeometry_map">
<area href="classEGS__BaseGeometry.html" alt="EGS_BaseGeometry" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>

<p><a href="classEGS__VHPGeometry-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9443b5783ac0db9bda829567f314366d"></a><!-- doxytag: member="EGS_VHPGeometry::EGS_VHPGeometry" ref="a9443b5783ac0db9bda829567f314366d" args="(const char *phantom_file, const char *media_file, int slice_min=0, int slice_max=1000000, const string &amp;Name=&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>EGS_VHPGeometry</b> (const char *phantom_file, const char *media_file, int slice_min=0, int slice_max=1000000, const string &amp;Name=&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a965fd75bf9c345a7bd8b11b1a0c9ae"></a><!-- doxytag: member="EGS_VHPGeometry::isInside" ref="a7a965fd75bf9c345a7bd8b11b1a0c9ae" args="(const EGS_Vector &amp;x)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInside</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d0e1277f88f9430b75dd60d5b6ad3b0"></a><!-- doxytag: member="EGS_VHPGeometry::isWhere" ref="a3d0e1277f88f9430b75dd60d5b6ad3b0" args="(const EGS_Vector &amp;x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>isWhere</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48977d61598d6ae8e8f34a1025f99b2f"></a><!-- doxytag: member="EGS_VHPGeometry::inside" ref="a48977d61598d6ae8e8f34a1025f99b2f" args="(const EGS_Vector &amp;x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>inside</b> (const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1483f5b7d5c505ebbff48da1b5d2906"></a><!-- doxytag: member="EGS_VHPGeometry::medium" ref="ae1483f5b7d5c505ebbff48da1b5d2906" args="(int ireg) const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>medium</b> (int ireg) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850df95115a1462528fa673e30ba3c4e"></a><!-- doxytag: member="EGS_VHPGeometry::computeIntersections" ref="a850df95115a1462528fa673e30ba3c4e" args="(int ireg, int n, const EGS_Vector &amp;X, const EGS_Vector &amp;u, EGS_GeometryIntersections *isections)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>computeIntersections</b> (int ireg, int n, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;X, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u, <a class="el" href="structEGS__GeometryIntersections.html">EGS_GeometryIntersections</a> *isections)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f7ee1505cace3f3ff045feb0e52b854"></a><!-- doxytag: member="EGS_VHPGeometry::howfarToOutside" ref="a7f7ee1505cace3f3ff045feb0e52b854" args="(int ireg, const EGS_Vector &amp;x, const EGS_Vector &amp;u)" -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>howfarToOutside</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e16f17eeb704f10edad9a61be960909"></a><!-- doxytag: member="EGS_VHPGeometry::howfar" ref="a8e16f17eeb704f10edad9a61be960909" args="(int ireg, const EGS_Vector &amp;x, const EGS_Vector &amp;u, EGS_Float &amp;t, int *newmed=0, EGS_Vector *normal=0)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>howfar</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;u, EGS_Float &amp;t, int *newmed=0, <a class="el" href="classEGS__Vector.html">EGS_Vector</a> *normal=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1d71a4767813d5641ddb4aa053fbe42"></a><!-- doxytag: member="EGS_VHPGeometry::hownear" ref="aa1d71a4767813d5641ddb4aa053fbe42" args="(int ireg, const EGS_Vector &amp;x)" -->
EGS_Float&#160;</td><td class="memItemRight" valign="bottom"><b>hownear</b> (int ireg, const <a class="el" href="classEGS__Vector.html">EGS_Vector</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad012995027e602cd3109aeedfebe0db2"></a><!-- doxytag: member="EGS_VHPGeometry::getMaxStep" ref="ad012995027e602cd3109aeedfebe0db2" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxStep</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a151b7a0ca854f74f64a203831a528ab3"></a><!-- doxytag: member="EGS_VHPGeometry::isOK" ref="a151b7a0ca854f74f64a203831a528ab3" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOK</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb18094f693b4c8f153466e15d2ab9c4"></a><!-- doxytag: member="EGS_VHPGeometry::getNx" ref="adb18094f693b4c8f153466e15d2ab9c4" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNx</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b063f76dcf298727ebd9a152a2d1fc"></a><!-- doxytag: member="EGS_VHPGeometry::getNy" ref="a84b063f76dcf298727ebd9a152a2d1fc" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNy</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4735522c92befbfa13a17c655c54cb1e"></a><!-- doxytag: member="EGS_VHPGeometry::getNz" ref="a4735522c92befbfa13a17c655c54cb1e" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNz</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acde806b107e7b9f19dd4b3a2e6a8d6a0"></a><!-- doxytag: member="EGS_VHPGeometry::getType" ref="acde806b107e7b9f19dd4b3a2e6a8d6a0" args="() const " -->
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getType</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a342fd24471690d66753fa2373a87336d"></a><!-- doxytag: member="EGS_VHPGeometry::printInfo" ref="a342fd24471690d66753fa2373a87336d" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>printInfo</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af00e60eaf130683f65c28a19f058810d"></a><!-- doxytag: member="EGS_VHPGeometry::setMicros" ref="af00e60eaf130683f65c28a19f058810d" args="(EGS_Input *)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMicros</b> (<a class="el" href="classEGS__Input.html">EGS_Input</a> *)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c50429f0b7a24b475967428779970b9"></a><!-- doxytag: member="EGS_VHPGeometry::setup" ref="a9c50429f0b7a24b475967428779970b9" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08fa635048ae7f9c6feaaefe74df47b9"></a><!-- doxytag: member="EGS_VHPGeometry::setMedia" ref="a08fa635048ae7f9c6feaaefe74df47b9" args="(EGS_Input *inp, int nmed, const int *med_ind)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMedia</b> (<a class="el" href="classEGS__Input.html">EGS_Input</a> *inp, int nmed, const int *med_ind)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0361076abb28bd87bde2eaa8c3c133bf"></a><!-- doxytag: member="EGS_VHPGeometry::vg" ref="a0361076abb28bd87bde2eaa8c3c133bf" args="" -->
EGS_VoxelGeometry *&#160;</td><td class="memItemRight" valign="bottom"><b>vg</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad268f97a93696865f5a83b1dd834f050"></a><!-- doxytag: member="EGS_VHPGeometry::organs" ref="ad268f97a93696865f5a83b1dd834f050" args="" -->
VHP_OrganData *&#160;</td><td class="memItemRight" valign="bottom"><b>organs</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2510e57f99dc0ddbf8634eaffdcbb4c1"></a><!-- doxytag: member="EGS_VHPGeometry::organ_media" ref="a2510e57f99dc0ddbf8634eaffdcbb4c1" args="[256]" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>organ_media</b> [256]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af27fa5912e6df5262cf93debd61bb0d9"></a><!-- doxytag: member="EGS_VHPGeometry::organ_micro" ref="af27fa5912e6df5262cf93debd61bb0d9" args="[256]" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>organ_micro</b> [256]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f08fb8ce430c09164334f82a58b4328"></a><!-- doxytag: member="EGS_VHPGeometry::organ_names" ref="a6f08fb8ce430c09164334f82a58b4328" args="[256]" -->
string&#160;</td><td class="memItemRight" valign="bottom"><b>organ_names</b> [256]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad35198c1639b7a5b7ed521b931273c55"></a><!-- doxytag: member="EGS_VHPGeometry::micros" ref="ad35198c1639b7a5b7ed521b931273c55" args="" -->
EGS_MicroMatrixCluster **&#160;</td><td class="memItemRight" valign="bottom"><b>micros</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b88c8000758df7a081482b77c9586ed"></a><!-- doxytag: member="EGS_VHPGeometry::nmicro" ref="a4b88c8000758df7a081482b77c9586ed" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>nmicro</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab98fe345569ca777f985db47a2566b78"></a><!-- doxytag: member="EGS_VHPGeometry::nmax" ref="ab98fe345569ca777f985db47a2566b78" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>nmax</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c85b3598fd967406054fa8d30c0b533"></a><!-- doxytag: member="EGS_VHPGeometry::nmacro" ref="a4c85b3598fd967406054fa8d30c0b533" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>nmacro</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab962e34b8d9113205aa8aa84788a00aa"></a><!-- doxytag: member="EGS_VHPGeometry::type" ref="ab962e34b8d9113205aa8aa84788a00aa" args="" -->
static string&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> = &quot;EGS_VHPGeometry&quot;</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A Voxelized Human Phantom (VHP) geometry. </p>
<p>This geometry type can be used to model a voxelized representation of a phantom. In principle a VHP geometry is the same as a XYZ geometry. The main reason for providing a separate implementation is the huge number of voxels needed to represent a whole body human phantom using 1-2 mm resolution, which necessitates a more careful memory use. In addition, this implementation provides the possibility to include a micro-voxel representation of the human spongiosa obtained from micro-CT images. A VHP geometry is defined as follows: </p>
<div class="fragment"><pre class="fragment">
 * library      = egs_vhp_geometry
 * name         = some_name
 * phantom data = phantom_data_file
 * media data   = media_data_file
 * slice range  = min_slice max_slice
 * </pre></div><p> In the above, the <code>slice range</code> input, which is optional, can be used to select a given slice range instead of using the entire phantom. The file <code>phantom_data_file</code> is a binary file containing the definition of the phantom. The format of this file is as follows:</p>
<ul>
<li>one byte indicating the endianess of the machine where the data was created (0=big endian, 1=little endian).</li>
<li>three 64 bit floating point values defining voxel size in x-, y- and z-direction</li>
<li>number of slices <code>nslice</code> (16 bit unsigned integer value). Note that increasing slice number corresponds to increasing z coordinate.</li>
<li>followed by the data for the <code>nslice</code> slices. The data for a slice consists of</li>
<li>first and last row (16 bit usigned integers)</li>
<li>followed by the last-first+1 data for a row The data for a row consists of</li>
<li>number <code>nreg</code> of regions (16 bit usigned integer)</li>
<li>followed by <code>nreg+1</code> pixel indeces <img class="formulaInl" alt="$p_j$" src="form_212.png"/> (16 bit usigned integers)</li>
<li>followed by <code>nreg</code> organ indeces <img class="formulaInl" alt="$O_j$" src="form_213.png"/> (8 bit unsigned integers) so that all voxels between <img class="formulaInl" alt="$p_j$" src="form_212.png"/> and <img class="formulaInl" alt="$p_{j+1}$" src="form_214.png"/> are set to organ <img class="formulaInl" alt="$O_j$" src="form_213.png"/>. This data structure, also used at run time, provides a significant compression compared to simply using an array of organ indeces (e.g., one needs about 12 MB to represent Richard Kramer's FAX phantom compared to about 150 MB that would be needed for the 1361 x 474 x 224 voxels of this phantom). Its disadvantage is the slighly slower ( <img class="formulaInl" alt="$\sim$" src="form_215.png"/> 10-15%) access to the organ index of a voxel.</li>
</ul>
<p>The file <code>media_data_file</code> is an ASCII file that defines the organ names and the materials to be used for each organ. Its format is as follows:</p>
<ul>
<li>number <img class="formulaInl" alt="$N$" src="form_103.png"/> of different organs</li>
<li>followed by <img class="formulaInl" alt="$N$" src="form_103.png"/> lines consisting of organ index, medium index and organ name.</li>
<li>followed by number of media <code>nmed</code></li>
<li>followed by <code>nmed</code> lines with a single medium name per line (media names are the actual medium names in the PEGS file to be used for the simulation).</li>
</ul>
<p>To add a micro-voxel representation of spongiosa, one includes in the geometry definition the following inputs: </p>
<div class="fragment"><pre class="fragment">
 * BSC thickness = thickness in cm
 * TB medium = medium name
 * BM medium = medium name
 * micro matrix = micro_data_file1 organ1 organ2 ...
 * micro matrix = micro_data_file2 organ1 organ2 ...
 * ...
 * </pre></div><p> The <code>TB medium</code> and <code>BM medium</code> inputs define the PEGS medium names of trabecular bone and bone marrow. The <code>BSC thickness</code> sets the thickness of the bone surface cells (BSC) layer. Note that in the current implementation the BSC thickness can not exceed the micro-voxel size. The binary files <code>micro_data_file_i</code> define micro matrix clusters to replace macro voxels that have organ indeces <code>organ1 organ2 ...</code>. A micro matrix cluster consists of <img class="formulaInl" alt="$M_x \times M_y \times M_z$" src="form_216.png"/> micro matrices of dimension <img class="formulaInl" alt="$N_x \times N_y \times N_z$" src="form_192.png"/>. This cluster is repeated periodically in spongiosa organs set to use this cluster. Note that the micro-matrix voxel size is automatically determned from the macro voxel size and the number of micro-voxels in a micro matrix. The format of the micro matrix file is as follows:</p>
<ul>
<li><img class="formulaInl" alt="$M_x, M_y, M_z$" src="form_217.png"/> (8 bit unsigned integers)</li>
<li>followed by <img class="formulaInl" alt="$N_x, N_y, N_z$" src="form_218.png"/> (8 bit unsigned integers)</li>
<li>followed by <img class="formulaInl" alt="$M_x \times M_y \times M_z \times N_x \times N_y \times N_z$" src="form_219.png"/> 8 bit integers defining the micro matrix medium (0 corresponds to trabecular bone, 1 to bone marrow). Note that bone marrow voxels neighboring trabecular bone are automatically marked to contain a BSC sub-volume. </li>
</ul>

<p>Definition at line <a class="el" href="egs__vhp__geometry_8h_source.html#l01304">1304</a> of file <a class="el" href="egs__vhp__geometry_8h_source.html">egs_vhp_geometry.h</a>.</p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/ftessier/EGSnrc/HEN_HOUSE/egs++/geometry/egs_vhp_geometry/<a class="el" href="egs__vhp__geometry_8h_source.html">egs_vhp_geometry.h</a></li>
<li>/home/ftessier/EGSnrc/HEN_HOUSE/egs++/geometry/egs_vhp_geometry/<a class="el" href="egs__vhp__geometry_8cpp_source.html">egs_vhp_geometry.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
